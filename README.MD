# Эмулятор работы языка программирования на ЭВМ

## Цель:

- Экспериментальное знакомство с устройством процессоров через моделирование;
получение опыта работы с компьютерной системой на нескольких уровнях организации, разрешая противоречия между ними.

### Данная лабораторная работа носит практический характер. Она включает разработку:

- языка программирования и транслятора;
- системы команд;
- модели процессора и его принципиальной схемы;
- нескольких алгоритмов (реализация и тестирование работы).

### Дополнительно:

- работа с CI;
- средства автоматического контроля качества кода;
- автоматическое тестирование.

## Вариант

```asm | cisc | harv | mc | tick | struct | trap | port | pstr | prob2 | spi```

```asm``` - синтаксис ассемблера. Необходима поддержка label-ов.

```cisc``` - система команд должна содержать сложные инструкции:
- переменная длина инструкций (некоторые инструкции не помещаются в машинное слово, даже в struct вариантах необходимо делать выборку за несколько шагов в явном виде);
- арифметические операции, работающие с регистрами и памятью за одну операцию;
- работа со специальными регистрами;

```harv``` - Гарвардская архитектура.

```mc``` - microcoded.
- В отчёте необходимо задокументировать уровень микроинструкций.
- Моделирование должно выполняться с точностью до такта.
- Микрокод должен быть сохранён в отдельной памяти для микропрограмм.
- Модель процессора должна исполнять микрокод.

```tick``` - процессор необходимо моделировать с точностью до такта, процесс моделирования может быть приостановлен на любом такте.

```struct``` - в виде высокоуровневой структуры данных. Считается, что одна инструкция укладывается в одно машинное слово, за исключением CISC архитектур.

```trap```

Ввод-вывод осуществляется токенами через систему прерываний. Логика работы:

- при старте модели у вас есть расписание ввода ([(1, 'h'), (10, 'e'), (20, 'l'), (25, 'l'), (100, 'o')], где цифра -- момент поступления данных, символ -- токен);
- процессор имеет систему прерываний:

    - прерывания считаем внутренними;
    - обработка прерывания должна приводить к вызову реализованного пользователем программного кода;
    - обработчик прерывания реализуется программистом на вашем языке;


- в процессе моделирования идёт отсчёт времени в тактах, по наступлении события ввода -- происходит обработка прерывания;
- из журнала работы процессора должно быть ясно, работаете вы в прерывании или нет;
- вывод данных реализуется посимвольно, как в варианте stream, по выполнении команд в буфер вывода добавляется ещё один символ;
- по окончании моделирования показать все выведенные данные;
- ситуация наступления прерывания во время обработки прерывания должна быть проработана (способ -- на ваше усмотрение);
- логика работы с буферами реализуется в рамках модели на Python;
- не стоит путать "вызов прерывания" и "получение данных".

```port``` - port-mapped (специальные инструкции для ввода-вывода)
- адресация портов ввода-вывода должна присутствовать.

```pstr``` - Length-prefixed (Pascal string)
- Статические строки должны храниться в памяти данных.
- Один символ может храниться в одном машинном слове (несмотря на явную неэффективность).

```prob2``` - Even Fibonacci numbers

Project Euler. Problem 2

Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:

1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...

By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.

```spi``` - ввод-вывод реализуется через интерфейс SPI (один канал на отправку и получение).
- необходима визуализация передачи данных через SPI.

## Язык программирования
```
program ::= terms

terms ::= term
        | terms term

term ::= instruction
       | label_def
       | directive


instruction ::= math_op
              | branch_op
              | alter_op
              | io_op
              | control_op
              | stack_op

math_op ::= math_opcode math_args
math_opcode ::= 'mov'
              | 'add'
              | 'sub'
              | 'cmp'

math_args ::= reg_id ',' reg_id
            | mem_by_reg_id ',' reg_id
            | reg_id ',' mem_by_reg_id
            | reg_id ',' label_ref
            | label_ref ',' reg_id
            | reg_id ',' immed


branch_op ::= branch_opcode branch_args
branch_opcode ::= 'jz'
                | 'jnz'
branch_args ::= label_ref


alter_op ::= alter_opcode alter_args
alter_opcode ::= 'inc'
               | 'dec'
alter_args ::= reg_id


io_op ::= io_opcode io_args
io_opcode ::= 'in'
            | 'out'
io_args ::= port_id


control_op ::= 'exit'
             | 'div'


stack_op ::= 'ret'
           | 'call' label_ref
           | 'pop' reg_id
           | 'push' push_args
push_args ::= reg_id
            | immed


mem_by_reg_id ::= '[' reg_id ']'
reg_id ::= 'eax'
         | 'ebx'
         | 'ecx'
         | 'edx'
         | 'esp'
         | 'eip'

immed ::= i32
        | symbol
port_id ::= i32

directive ::= "word" literal
literal ::= immed
          | string

label_ref ::= label_id
label_def ::= label_id ':'
label_id ::= /^[a-zA-Z0-9_]+$/i


i32 ::= <целое число>
symbol ::= <символ, заключённый в одинарные кавычки>
string ::= <строка, заключённая в двойные кавычки>
```

